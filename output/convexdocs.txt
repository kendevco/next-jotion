Setting up a web app with Convex and NextJS
Denis Tarasenko
Denis Tarasenko

·
Follow

3 min read
·
Jan 18, 2024
13







Photo by Christopher Gower on Unsplash
I’m in love building websites, whether it’s front-end work or back-end. However, sometimes you’ve just got an idea that you want to scaffold right away without spending much time on API and database. Luckily, thanks to Web Dev Cody channel, I found out about Convex, a tool that does all of API-database tedious configuration for you, and moreover, giving you a lot of additional complex features you might use, such as Web Sockets that update data dynamically on the layout.

Setting up a NextJS project
Create a NextJS app using the following command

npx create-next-app@latest nextjs-convex-app
Installing and configuring Convex
Navigate to your app

cd nextjs-convex-app
and install convex package that provides a convenient interface for working with Convex from NextJS app

npm install convex
Remember that all the steps above I take straight from the Convex docs.

Then, run npx convex dev command to get convex rolling. It'll prompt you to log in with Github, create a project, and save a production and deployment URLs.

npx convex dev
Populating Convex database with sample data
You got a NextJS and Convex in place, now it’s time to start working with them both.

Populate Convex database with sample data by creating a file sampleData.jsonl at the root of the project and adding there the next data

{"text": "Beat Witcher 3", "isCompleted": true}
{"text": "Meditate by imagining yourself in the inn near the Novigrad", "isCompleted": false}
{"text": "Put yourself together", "isCompleted": false}
Add this data to Convex database

npx convex import --table tasks sampleData.jsonl
Exporting a GET query to fetch the data
Inside of convex/ folder create tasks.ts file that will be a store for query functions. Write and export GET query

convex/tasks.ts

import { query } from "./_generated/server";

export const get = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("tasks").collect();
  },
});
Creating Convex provider for NextJS
Add a new file ConvexClientProvider.tsx in the /app folder. This must be a client component so place use client at the top of the file and copy paste the following code there as well

ConvexClientProvider.tsx

"use client";
import { ReactNode } from "react";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
export default function ConvexClientProvider({
  children,
}: {
  children: ReactNode;
}) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
Wrap children up in ConvexClientProvider
Open layout.tsx file inside of /app folder, import created ConvexProvider and wrap up children with it

/app/layout.tsx

import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import ConvexClientProvider from "./ConvexClientProvider";

const inter = Inter({ subsets: ["latin"] });
export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ConvexClientProvider>{children}</ConvexClientProvider>
      </body>
    </html>
  );
}
Display the data in your app
To use queries exported from convex/tasks.ts, Convex gives a very convenient function useQuery that takes a query as a parameter and then does all complicated stuff for you, you are left only to display the data

/app/page.tsx

"use client";
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export default function Home() {
  const tasks = useQuery(api.tasks.get);
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      {tasks?.map(({ _id, text }) => <div key={_id}>{text}</div>)}
    </main>
  );
}
Playing around with Convex interface
Run a NextJS app

npm run dev
you’ll see the data displayed. Go to https://dashboard.convex.dev, choose your project, and then change some data there and get back to localhost — the data was changed dynamically!

Conclusion
Now with Convex, you’ve got a bunch of cool projects to try out. It takes care of all the tricky stuff with APIs and databases, so you can just focus on bringing your ideas to life. Enjoy coding without the hassle!

Original blog post from my website — https://denistarasenko.com/blog/convex-with-nextjs

Module: nextjs
Helpers for integrating Convex into Next.js applications using server rendering.

This module contains:

preloadQuery, for preloading data for reactive client components.
fetchQuery, fetchMutation and fetchAction for loading and mutating Convex data from Next.js Server Components, Server Actions and Route Handlers.
Usage
All exported functions assume that a Convex deployment URL is set in the NEXT_PUBLIC_CONVEX_URL environment variable. npx convex dev will automatically set it during local development.

Preloading data
Preload data inside a Server Component:

import { preloadQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";
import ClientComponent from "./ClientComponent";

export async function ServerComponent() {
  const preloaded = await preloadQuery(api.foo.baz);
  return <ClientComponent preloaded={preloaded} />;
}

And pass it to a Client Component:

import { Preloaded, usePreloadedQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";

export function ClientComponent(props: {
  preloaded: Preloaded<typeof api.foo.baz>;
}) {
  const data = await usePreloadedQuery(props.preloaded);
  // render `data`...
}

Type Aliases
NextjsOptions
Ƭ NextjsOptions: Object

Options to preloadQuery, fetchQuery, fetchMutation and fetchAction.

Type declaration
Name	Type	Description
token?	string	The JWT-encoded OpenID Connect authentication token to use for the function call.
url?	string	The URL of the Convex deployment to use for the function call. Defaults to process.env.NEXT_PUBLIC_CONVEX_URL.
skipConvexDeploymentUrlCheck?	boolean	Skip validating that the Convex deployment URL looks like https://happy-animal-123.convex.cloud or localhost. This can be useful if running a self-hosted Convex backend that uses a different URL. The default value is false
Defined in
nextjs/index.ts:59

Functions
preloadQuery
▸ preloadQuery<Query>(query, ...args): Promise<Preloaded<Query>>

Execute a Convex query function and return a Preloaded payload which can be passed to usePreloadedQuery in a Client Component.

Type parameters
Name	Type
Query	extends FunctionReference<"query">
Parameters
Name	Type	Description
query	Query	a FunctionReference for the public query to run like api.dir1.dir2.filename.func.
...args	ArgsAndOptions<Query, NextjsOptions>	The arguments object for the query. If this is omitted, the arguments will be {}.
Returns
Promise<Preloaded<Query>>

A promise of the Preloaded payload.

Defined in
nextjs/index.ts:98

preloadedQueryResult
▸ preloadedQueryResult<Query>(preloaded): FunctionReturnType<Query>

Returns the result of executing a query via preloadQuery.

Type parameters
Name	Type
Query	extends FunctionReference<"query">
Parameters
Name	Type	Description
preloaded	Preloaded<Query>	The Preloaded payload returned by preloadQuery.
Returns
FunctionReturnType<Query>

The query result.

Defined in
nextjs/index.ts:117

fetchQuery
▸ fetchQuery<Query>(query, ...args): Promise<FunctionReturnType<Query>>

Execute a Convex query function.

Type parameters
Name	Type
Query	extends FunctionReference<"query">
Parameters
Name	Type	Description
query	Query	a FunctionReference for the public query to run like api.dir1.dir2.filename.func.
...args	ArgsAndOptions<Query, NextjsOptions>	The arguments object for the query. If this is omitted, the arguments will be {}.
Returns
Promise<FunctionReturnType<Query>>

A promise of the query's result.

Defined in
nextjs/index.ts:133

fetchMutation
▸ fetchMutation<Mutation>(mutation, ...args): Promise<FunctionReturnType<Mutation>>

Execute a Convex mutation function.

Type parameters
Name	Type
Mutation	extends FunctionReference<"mutation">
Parameters
Name	Type	Description
mutation	Mutation	A FunctionReference for the public mutation to run like api.dir1.dir2.filename.func.
...args	ArgsAndOptions<Mutation, NextjsOptions>	The arguments object for the mutation. If this is omitted, the arguments will be {}.
Returns
Promise<FunctionReturnType<Mutation>>

A promise of the mutation's result.

Defined in
nextjs/index.ts:152

fetchAction
▸ fetchAction<Action>(action, ...args): Promise<FunctionReturnType<Action>>

Execute a Convex action function.

Type parameters
Name	Type
Action	extends FunctionReference<"action">
Parameters
Name	Type	Description
action	Action	A FunctionReference for the public action to run like api.dir1.dir2.filename.func.
...args	ArgsAndOptions<Action, NextjsOptions>	The arguments object for the action. If this is omitted, the arguments will be {}.
Returns
Promise<FunctionReturnType<Action>>

A promise of the action's result.

Defined in
nextjs/index.ts:173

Schemas
A schema is a description of
the tables in your Convex project
the type of documents within your tables
While it is possible to use Convex without defining a schema, adding a schema.ts file will ensure that the documents in your tables are the correct type. If you're using TypeScript, adding a schema will also give you end-to-end type safety throughout your app.
We recommend beginning your project without a schema for rapid prototyping and then adding a schema once you've solidified your plan. To learn more see our Schema Philosophy.
Example: TypeScript and Schemas
Writing schemas
Schemas are defined in a schema.ts file in your convex/ directory and look like:
convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
export default defineSchema({
  messages: defineTable({
    body: v.string(),
    user: v.id("users"),
  }),
  users: defineTable({
    name: v.string(),
    tokenIdentifier: v.string(),
  }).index("by_token", ["tokenIdentifier"]),
});
This schema (which is based on our users and auth example), has 3 tables: channels, messages, and users. Each table is defined using the defineTable function. Within each table, the document type is defined using the validator builder, v. In addition to the fields listed, Convex will also automatically add _id and _creationTime fields. To learn more, see System Fields.
GENERATING A SCHEMA
While writing your schema, it can be helpful to consult the Convex Dashboard. The "Generate Schema" button in the "Data" view suggests a schema declaration based on the data in your tables.
Validators
The validator builder, v is used to define the type of documents in each table. It has methods for each of Convex's types:
convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
export default defineSchema({
  documents: defineTable({
    id: v.id("documents"),
    string: v.string(),
    number: v.number(),
    boolean: v.boolean(),
    nestedObject: v.object({
      property: v.string(),
    }),
  }),
});
It additionally allows you to define unions, optional property, string literals, and more. Argument validation and schemas both use the same validator builder, v.
Optional fields
You can describe optional fields by wrapping their type with v.optional(...):
defineTable({
  optionalString: v.optional(v.string()),
  optionalNumber: v.optional(v.number()),
});
This corresponds to marking fields as optional with ? in TypeScript.
Unions
You can describe fields that could be one of multiple types using v.union:
defineTable({
  stringOrNumber: v.union(v.string(), v.number()),
});
If your table stores multiple different types of documents, you can use v.union at the top level:
defineTable(
  v.union(
    v.object({
      kind: v.literal("StringDocument"),
      value: v.string(),
    }),
    v.object({
      kind: v.literal("NumberDocument"),
      value: v.number(),
    }),
  ),
);
In this schema, documents either have a kind of "StringDocument" and a string for their value:
{
  "kind": "StringDocument",
  "value": "abc"
}
or they have a kind of "NumberDocument" and a number for their value:
{
  "kind": "NumberDocument",
  "value": 123
}
Literals
Fields that are a constant can be expressed with v.literal:
defineTable({
  oneTwoOrThree: v.union(
    v.literal("one"),
    v.literal("two"),
    v.literal("three"),
  ),
});
Any
Fields or documents that could take on any value can be represented with v.any():
defineTable({
  anyValue: v.any(),
});
This corresponds to the any type in TypeScript.
Options
These options are passed as part of the options argument to defineSchema.
schemaValidation: boolean
Whether Convex should validate at runtime that your documents match your schema.
By default, Convex will enforce that all new and existing documents match your schema.
You can disable schemaValidation by passing in schemaValidation: false:
defineSchema(
  {
    // Define tables here.
  },
  {
    schemaValidation: false,
  },
);
When schemaValidation is disabled, Convex will not validate that new or existing documents match your schema. You'll still get schema-specific TypeScript types, but there will be no validation at runtime that your documents match those types.
strictTableNameTypes: boolean
Whether the TypeScript types should allow accessing tables not in the schema.
By default, the TypeScript table name types produced by your schema are strict. That means that they will be a union of strings (ex. "messages" | "channels") and only support accessing tables explicitly listed in your schema.
Sometimes it's useful to only define part of your schema. For example, if you are rapidly prototyping, it could be useful to try out a new table before adding it your schema.ts file.
You can disable strictTableNameTypes by passing in strictTableNameTypes: false:
defineSchema(
  {
    // Define tables here.
  },
  {
    strictTableNameTypes: false,
  },
);
When strictTableNameTypes is disabled, the TypeScript types will allow access to tables not listed in the schema and their document type will be any.
Regardless of the value of strictTableNameTypes, your schema will only validate documents in the tables listed in the schema. You can still create and modify documents in other tables in JavaScript or on the dashboard (they just won't be validated).
Schema validation
Schemas are pushed automatically in npx convex dev and npx convex deploy.
The first push after a schema is added or modified will validate that all existing documents match the schema. If there are documents that fail validation, the push will fail.
After the schema is pushed, Convex will validate that all future document inserts and updates match the schema.
Schema validation is skipped if schemaValidation is set to false.
Note that schemas only validate documents in the tables listed in the schema. You can still create and modify documents in other tables (they just won't be validated).
Circular references
You might want to define a schema with circular ID references like:
convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
export default defineSchema({
  users: defineTable({
    preferencesId: v.id("preferences"),
  }),
  preferences: defineTable({
    userId: v.id("users"),
  }),
});
In this schema, documents in the users table contain a reference to documents in preferences and vice versa.
Because schema validation enforces your schema on every db.insert, db.replace, and db.patch call, creating circular references like this is not possible.
The easiest way around this is to make one of the references nullable:
convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
export default defineSchema({
  users: defineTable({
    preferencesId: v.id("preferences"),
  }),
  preferences: defineTable({
    userId: v.union(v.id("users"), v.null()),
  }),
});
This way you can create a preferences document first, then create a user document, then set the reference on the preferences document:
convex/users.ts
TS
import { mutation } from "./_generated/server";
export default mutation(async (ctx) => {
  const preferencesId = await ctx.db.insert("preferences", {});
  const userId = await ctx.db.insert("users", { preferencesId });
  await ctx.db.patch(preferencesId, { userId });
});
Let us know if you need better support for circular references.
TypeScript types
Once you've defined a schema, npx convex dev will produce new versions of dataModel.d.ts and server.d.ts with types based on your schema.
Doc<TableName>
The Doc TypeScript type from dataModel.d.ts provides document types for all of your tables. You can use these both when writing Convex functions and in your React components:
MessageView.tsx
import { Doc } from "../convex/_generated/dataModel";
function MessageView(props: { message: Doc<"messages"> }) {
  ...
}
If you need the type for a portion of a document, use the Infer type helper.
query and mutation
The query and mutation functions in server.js have the same API as before but now provide a db with more precise types. Functions like db.insert(table, document) now understand your schema. Additionally database queries will now return the correct document type (not any).
Data Types
All Convex documents are defined as Javascript objects. These objects can have field values of any of the types below.
You can codify the shape of documents within your tables by defining a schema.
Convex values
Convex supports the following types of values:
Convex Type	TS/JS Type	
Example Usage
Validator for Argument Validation and Schemas	json Format for Export	Notes
Id	string	doc._id	v.id(tableName)	string	See Document IDs.
Null	null	null	v.null()	null	JavaScript's undefined is not a valid Convex value. Use null instead.
Int64	bigint	3n	v.int64()	string (base10)	Int64s only support BigInts between -2^63 and 2^63-1. Convex supports bigints in most modern browsers.
Float64	number	3.1	v.number()	number / string	Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.
Boolean	boolean	true	v.boolean()	bool	
String	string	"abc"	v.string()	string	Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.
Bytes	ArrayBuffer	new ArrayBuffer(8)	v.bytes()	string (base64)	Convex supports first class bytestrings, passed in as ArrayBuffers. Bytestrings must be smaller than the 1MB total size limit for Convex types.
Array	Array	[1, 3.2, "abc"]	v.array(values)	array	Arrays can have at most 8192 values.
Object	Object	{a: "abc"}	v.object({property: value})	object	Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Convex includes all enumerable properties. Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "_".
System fields
Every document in Convex has two automatically-generated system fields:
_id: The document ID of the document.
_creationTime: The time this document was created, in milliseconds since the Unix epoch.
Limits
Convex values must be less than 1MB in total size. This is an approximate limit for now, but if you're running into these limits and would like a more precise method to calculate a document's size, reach out to us. Documents can have nested values, either objects or arrays that contain other Convex types. Convex types can have at most 16 levels of nesting, and the cumulative size of a nested tree of values must be under the 1MB limit.
Table names may contain alphanumeric characters ("a" to "z", "A" to "Z", and "0" to "9") and underscores ("_"), and they cannot start with an underscore.
For information on other limits, see here.
If any of these limits don't work for you, let us know!
Working with dates and times
Convex does not have a special data type for working with dates and times. How you store dates depends on the needs of your application:
If you only care about a point in time, you can store a UTC timestamp. We recommend following the _creationTime field example, which stores the timestamp as a number in milliseconds. In your functions and on the client you can create a JavaScript Date by passing the timestamp to its constructor: new Date(timeInMsSinceEpoch). You can then print the date and time in the desired time zone (such as your user's machine's configured time zone).
To get the current UTC timestamp in your function and store it in the database, use Date.now()
If you care about a calendar date or a specific clock time, such as when implementing a booking app, you should store the actual date and/or time as a string. If your app supports multiple timezones you should store the timezone as well. ISO8601 is a common format for storing dates and times together in a single string like "2024-03-21T14:37:15Z". If your users can choose a specific time zone you should probably store it in a separate string field, usually using the IANA time zone name (although you could concatenate the two fields with unique character like "|").
For more sophisticated printing (formatting) and manipulation of dates and times use one of the popular JavaScript libraries: date-fns, Day.js, Luxon or Moment.js.
Document IDs
Example: Relational Data Modeling
Every document in convex has a globally unique string document ID that is automatically generated by the system.
const userId = await ctx.db.insert("users", { name: "Michael Jordan" });
You can use this ID to efficiently read a single document using the get method:
const retrievedUser = await ctx.db.get(userId);
You can access the ID of a document in the _id field:
const userId = retrievedUser._id;
Also, this same ID can be used to update that document in place:
await ctx.db.patch(userId, { name: "Steph Curry" });
Convex generates an Id TypeScript type based on your schema that is parameterized over your table names:
import { Id } from "./_generated/dataModel";
const userId: Id<"users"> = user._id;
IDs are strings at runtime, but the Id type can be used to distinguish IDs from other strings at compile time.
References and relationships
In Convex, you can reference a document simply by embedding its Id in another document:
await ctx.db.insert("books", {
  title,
  ownerId: user._id,
});
You can follow references with ctx.db.get:
const user = await ctx.db.get(book.ownerId);
And query for documents with a reference:
const myBooks = await ctx.db
  .query("books")
  .filter((q) => q.eq(q.field("ownerId"), user._id))
  .collect();
Using Ids as references can allow you to build a complex data model.
Trading off deeply nested documents vs. relationships
While it's useful that Convex supports nested objects and arrays, should keep documents relatively small in size. In practice, we recommend limiting Arrays to no more than 5-10 elements and avoiding deeply nested Objects.
Instead, leverage separate tables, documents, and references to structure your data. This will lead to better maintainability and performance as your project grows.
Serializing IDs
IDs are strings, which can be easily inserted into URLs or stored outside of Convex.
You can pass an ID string from an external source (like a URL) into a Convex function and get the corresponding object. If you're using TypeScript on the client you can cast a string to the Id type:
src/App.tsx
import { useQuery } from "convex/react";
import { Id } from "../convex/_generated/dataModel";
import { api } from "../convex/_generated/api";
export function App() {
  const id = localStorage.getItem("myIDStorage");
  const task = useQuery(api.tasks.getTask, { taskId: id as Id<"tasks"> });
  // ...
}
Since this ID is coming from an external source, use an argument validator or ctx.db.normalizeId to confirm that the ID belongs to the expected table before returning the object.
convex/tasks.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const getTask = query({
  args: {
    taskId: v.id("tasks"),
  },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.taskId);
    // ...
  },
});
Writing Data
Mutations can insert, update, and remove data from database tables.
Inserting new documents
You can create new documents in the database with the db.insert method:
convex/tasks.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const createTask = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    const taskId = await ctx.db.insert("tasks", { text: args.text });
    // do something with `taskId`
  },
});
The second argument to db.insert is a JavaScript object with data for the new document.
The same types of values that can be passed into and returned from queries and mutations can be written into the database. See Data Types for the full list of supported types.
The insert method returns a globally unique ID for the newly inserted document.
Updating existing documents
Given an existing document ID the document can be updated using the following methods:
The db.patch method will patch an existing document, shallow merging it with the given partial document. New fields are added. Existing fields are overwritten. Fields set to undefined are removed.
convex/tasks.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const updateTask = mutation({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    const { id } = args;
    console.log(await ctx.db.get(id));
    // { text: "foo", status: { done: true }, _id: ... }
    // Add `tag` and overwrite `status`:
    await ctx.db.patch(id, { tag: "bar", status: { archived: true } });
    console.log(await ctx.db.get(id));
    // { text: "foo", tag: "bar", status: { archived: true }, _id: ... }
    // Unset `tag` by setting it to `undefined`
    await ctx.db.patch(id, { tag: undefined });
    console.log(await ctx.db.get(id));
    // { text: "foo", status: { archived: true }, _id: ... }
  },
});
The db.replace method will replace the existing document entirely, potentially removing existing fields:
convex/tasks.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const replaceTask = mutation({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    const { id } = args;
    console.log(await ctx.db.get(id));
    // { text: "foo", _id: ... }
    // Replace the whole document
    await ctx.db.replace(id, { invalid: true });
    console.log(await ctx.db.get(id));
    // { invalid: true, _id: ... }
  },
});
Deleting documents
Given an existing document ID the document can be removed from the table with the db.delete method.
convex/tasks.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const deleteTask = mutation({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
});
Write performance and limits
To prevent accidental writes of large amounts of records, queries and mutations enforce limits detailed here.
Reading Data
Query and mutation functions can read data from database tables using document ids and document queries.
Reading a single document
Given a single document's id you can read its data with the db.get method:
convex/tasks.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const getTask = query({
  args: { taskId: v.id("tasks") },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.taskId);
    // do something with `task`
  },
});
Note: You should use the v.id validator like in the example above to make sure you are not exposing data from tables other than the ones you intended.
Querying documents
Document queries always begin by choosing the table to query with the db.query method:
convex/tasks.ts
TS
import { query } from "./_generated/server";
export const listTasks = query({
  handler: async (ctx) => {
    const tasks = await ctx.db.query("tasks").collect();
    // do something with `tasks`
  },
});
Then you can:
filter
order
and await the results
We'll see how this works in the examples below.
Filtering
The filter method allows you to restrict the documents that your document query returns. This method takes a filter constructed by FilterBuilder and will only select documents that match.
The examples below demonstrate some of the common uses of filter. You can see the full list of available filtering methods in the reference docs.
If you need to filter to documents containing some keywords, use a search query.
Equality conditions
This document query finds documents in the users table where doc.name === "Alex":
// Get all users named "Alex".
const usersNamedAlex = await ctx.db
  .query("users")
  .filter((q) => q.eq(q.field("name"), "Alex"))
  .collect();
Here q is the FilterBuilder utility object. It contains methods for all of our supported filter operators.
This filter will run on all documents in the table. For each document, q.field("name") evaluates to the name property. Then q.eq checks if this property is equal to "Alex".
If your query references a field that is missing from a given document then that field will be considered to have the value undefined.
Comparisons
Filters can also be used to compare fields against values. This document query finds documents where doc.age >= 18:
// Get all users with an age of 18 or higher.
const adults = await ctx.db
  .query("users")
  .filter((q) => q.gte(q.field("age"), 18))
  .collect();
Here the q.gte operator checks if the first argument (doc.age) is greater than or equal to the second (18).
Here's the full list of comparisons:
Operator	Equivalent TypeScript
q.eq(l, r)	l === r
q.neq(l, r)	l !== r
q.lt(l, r)	l < r
q.lte(l, r)	l <= r
q.gt(l, r)	l > r
q.gte(l, r)	l >= r
Arithmetic
You can also include basic arithmetic in your queries. This document query finds documents in the carpets table where doc.height * doc.width > 100:
// Get all carpets that have an area of over 100.
const largeCarpets = await ctx.db
  .query("carpets")
  .filter((q) => q.gt(q.mul(q.field("height"), q.field("width")), 100))
  .collect();
Here's the full list of arithmetic operators:
Operator	Equivalent TypeScript
q.add(l, r)	l + r
q.sub(l, r)	l - r
q.mul(l, r)	l * r
q.div(l, r)	l / r
q.mod(l, r)	l % r
q.neg(x)	-x
Combining operators
You can construct more complex filters using methods like q.and, q.or, and q.not. This document query finds documents where doc.name === "Alex" && doc.age >= 18:
// Get all users named "Alex" whose age is at least 18.
const adultAlexes = await ctx.db
  .query("users")
  .filter((q) =>
    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18)),
  )
  .collect();
Here is a query that finds all users where doc.name === "Alex" || doc.name === "Emma":
// Get all users named "Alex" or "Emma".
const usersNamedAlexOrEmma = await ctx.db
  .query("users")
  .filter((q) =>
    q.or(q.eq(q.field("name"), "Alex"), q.eq(q.field("name"), "Emma")),
  )
  .collect();
Ordering
By default Convex always returns documents ordered by _creationTime.
You can use .order("asc" | "desc") to pick whether the order is ascending or descending. If the order isn't specified, it defaults to ascending.
// Get all messages, oldest to newest.
const messages = await ctx.db.query("messages").order("asc").collect();
// Get all messages, newest to oldest.
const messages = await ctx.db.query("messages").order("desc").collect();
If you need to sort on a field other than _creationTime and your document query returns a small number of documents (on the order of hundreds rather than thousands of documents), consider sorting in Javascript:
// Get top 10 most liked messages, assuming messages is a fairly small table:
const messages = await ctx.db.query("messages").collect();
const topTenMostLikedMessages = recentMessages
  .sort((a, b) => b.likes - a.likes)
  .slice(0, 10);
For document queries that return larger numbers of documents, you'll want to use an index to improve the performance. Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.
// Get the top 20 most liked messages of all time, using the "by_likes" index.
const messages = await ctx.db
  .query("messages")
  .withIndex("by_likes")
  .order("desc")
  .take(20);
See Limit expressions with indexes for details.
Ordering of different types of values
A single field can have values of any Convex type. When there are values of different types in an indexed field, their ascending order is as follows:
No value set (undefined) < Null (null) < Int64 (bigint) < Float64 (number) < Boolean (boolean) < String (string) < Bytes (ArrayBuffer) < Array (Array) < Object (Object)
The same ordering is used by the filtering comparison operators q.lt(), q.lte(), q.gt() and q.gte().
Retrieving results
Most of our previous examples have ended the document query with the .collect() method, which returns all the documents that match your filters. Here are the other options for retrieving results.
Taking n results
.take(n) selects only the first n results that match your query.
const users = await ctx.db.query("users").take(5);
Finding the first result
.first() selects the first document that matches your query and returns null if no documents were found.
// We expect only one user with that email address.
const userOrNull = await ctx.db
  .query("users")
  .filter((q) => q.eq(q.field("email"), "test@example.com"))
  .first();
Using a unique result
.unique() selects the single document from your query or returns null if no documents were found. If there are multiple results it will throw an exception.
// Our counter table only has one document.
const counterOrNull = await ctx.db.query("counter").unique();
Loading a page of results
.paginate(opts) loads a page of results and returns a Cursor for loading additional results.
See Paginated Queries to learn more.
More complex queries
Convex prefers to have a few, simple ways to walk through and select documents from tables. In Convex, there is no specific query language for complex logic like a join, an aggregation, or a group by.
Instead, you can write the complex logic in Javascript! Convex guarantees that the results will be consistent.
Join
Table join might look like:
convex/events.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const eventAttendees = query({
  args: { eventId: v.id("events") },
  handler: async (ctx, args) => {
    const event = await ctx.db.get(args.eventId);
    return Promise.all(
      (event?.attendeeIds ?? []).map((userId) => ctx.db.get(userId)),
    );
  },
});
Aggregation
Here's an example of computing an average:
convex/purchases.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const averagePurchasePrice = query({
  args: { email: v.string() },
  handler: async (ctx, args) => {
    const userPurchases = await ctx.db
      .query("purchases")
      .filter((q) => q.eq(q.field("buyer"), args.email))
      .collect();
    const sum = userPurchases.reduce((a, { value: b }) => a + b, 0);
    return sum / userPurchases.length;
  },
});
Group by
Here's an example of grouping and counting:
convex/purchases.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const numPurchasesPerBuyer = query({
  args: { email: v.string() },
  handler: async (ctx, args) => {
    const userPurchases = await ctx.db.query("purchases").collect();
    return userPurchases.reduce(
      (counts, { buyer }) => ({
        ...counts,
        [buyer]: counts[buyer] ?? 0 + 1,
      }),
      {} as Record<string, number>,
    );
  },
});
Querying performance and limits
Most of the example document queries above can lead to a full table scan. That is, for the document query to return the requested results, it might need to walk over every single document in the table.
Take this simple example:
const tasks = await ctx.db.query("tasks").take(5);
This document query will not scan more than 5 documents.
On the other hand, this document query:
const tasks = await ctx.db
  .query("tasks")
  .filter((q) => q.eq(q.field("isCompleted"), true))
  .first();
might need to walk over every single document in the "tasks" table just to find the first one with isCompleted: true.
If a table has more than a few thousand documents, you should use indexes to improve your document query performance. Otherwise, you may run into our enforced limits, detailed here.
For information on other limits, see here.
Explore the syntax on the dashboard
You can try out the syntax described above directly from the dashboard by writing a custom test query.
Tables & Documents
Tables
Your Convex deployment contains tables that hold your app's data. Initially, your deployment contains no tables or documents.
Each table springs into existence as soon as you add the first document to it.
// `friends` table doesn't exist.
await ctx.db.insert("friends", { name: "Jamie" });
// Now it does, and it has one document.
You do not have to specify a schema up front or create tables explicitly.
Documents
Tables contain documents. Documents are very similar to JavaScript objects. They have fields and values, and you can nest arrays or objects within them.
These are all valid Convex documents:
{}
{"name": "Jamie"}
{"name": {"first": "Ari", "second": "Cole"}, "age": 60}
They can also contain references to other documents in other tables. See Data Types to learn more about the types supported in Convex and Document IDs to learn about how to use those types to model your data.
Queries
Queries are the bread and butter of your backend API. They fetch data from the database, check authentication or perform other business logic, and return data back to the client application.
This is an example query, taking in named arguments, reading data from the database and returning a result:
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
// Return the last 100 tasks in a given task list.
export const getTaskList = query({
  args: { taskListId: v.id("taskLists") },
  handler: async (ctx, args) => {
    const tasks = await ctx.db
      .query("tasks")
      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))
      .order("desc")
      .take(100);
    return tasks;
  },
});
Read on to understand how to build queries yourself.
Query names
Queries are defined in 
TypeScript
 files inside your convex/ directory.
The path and name of the file, as well as the way the function is exported from the file, determine the name the client will use to call it:
convex/myFunctions.ts
TS
// This function will be referred to as `api.myFunctions.myQuery`.
export const myQuery = …;
// This function will be referred to as `api.myFunctions.sum`.
export const sum = …;
To structure your API you can nest directories inside the convex/ directory:
convex/foo/myQueries.ts
TS
// This function will be referred to as `api.foo.myQueries.listMessages`.
export const listMessages = …;
Default exports receive the name default.
convex/myFunctions.ts
TS
// This function will be referred to as `api.myFunctions.default`.
export default …;
The same rules apply to mutations and actions, while HTTP actions use a different routing approach.
Client libraries in languages other than JavaScript and TypeScript use strings instead of API objects:
api.myFunctions.myQuery is "myFunctions:myQuery"
api.foo.myQueries.myQuery is "foo/myQueries:myQuery".
api.myFunction.default is "myFunction:default" or "myFunction".
The query constructor
To actually declare a query in Convex you use the query constructor function. Pass it an object with a handler function, which returns the query result:
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
export const myConstantString = query({
  handler: () => {
    return "My never changing string";
  },
});
Query arguments
Queries accept named arguments. The argument values are accessible as fields of the second parameter of the handler function:
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
export const sum = query({
  handler: (_, args: { a: number; b: number }) => {
    return args.a + args.b;
  },
});
Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your query.
To both declare the types of arguments and to validate them, add an args object using v validators:
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const sum = query({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    return args.a + args.b;
  },
});
See argument validation for the full list of supported types and validators.
The first parameter of the handler function contains the query context.
Query responses
Queries can return values of any supported Convex type which will be automatically serialized and deserialized.
Queries can also return undefined, which is not a valid Convex value. When a query returns undefined it is translated to null on the client.
Query context
The query constructor enables fetching data, and other Convex features by passing a QueryCtx object to the handler function as the first parameter:
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const myQuery = query({
  args: { a: v.number(), b: v.number() },
  handler: (ctx, args) => {
    // Do something with `ctx`
  },
});
Which part of the query context is used depends on what your query needs to do:
To fetch from the database use the db field. Note that we make the handler function an async function so we can await the promise returned by db.get():
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
import { v } from "convex/values";
export const getTask = query({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});
Read more about Reading Data.
To return URLs to stored files use the storage field. Read more about File Storage.
To check user authentication use the auth field. Read more about Authentication.
Using NPM packages
Queries can import NPM packages installed in node_modules. Not all NPM packages are supported, see Runtimes for more details.
npm install @faker-js/faker
convex/myFunctions.ts
TS
import { query } from "./_generated/server";
import { faker } from "@faker-js/faker";
export const randomName = query({
  args: {},
  handler: () => {
    faker.seed();
    return faker.person.fullName();
  },
});
Calling queries from clients
To call a query from React use the useQuery hook along with the generated api object.
src/MyApp.tsx
TS
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";
export function MyApp() {
  const data = useQuery(api.myFunctions.sum, { a: 1, b: 2 });
  // do something with `data`
}
See the React client documentation for all the ways queries can be called.
Caching & reactivity
Queries have two awesome attributes:
Caching: Convex caches query results automatically. If many clients request the same query, with the same arguments, they will receive a cached response.
Reactivity: clients can subscribe to queries to receive new results when the underlying data changes.
To have these attributes the handler function must be deterministic, which means that given the same arguments (including the query context) it will return the same response.
For this reason queries cannot call third party APIs. To call third party APIs, use actions.
You might wonder whether you can use non-deterministic language functionality like Math.random() or Date.now(). The short answer is that Convex takes care of implementing these in a way that you don't have to think about the deterministic constraint.
See Runtimes for more details on the Convex runtime.
Mutations
Mutations insert, update and remove data from the database, check authentication or perform other business logic, and optionally return a response to the client application.
This is an example mutation, taking in named arguments, writing data to the database and returning a result:
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
// Create a new task with the given text
export const createTask = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    const newTaskId = await ctx.db.insert("tasks", { text: args.text });
    return newTaskId;
  },
});
Read on to understand how to build mutations yourself.
Mutation names
Mutations follow the same naming rules as queries, see Query names.
Queries and mutations can be defined in the same file when using named exports.
The mutation constructor
To declare a mutation in Convex use the mutation constructor function. Pass it an object with a handler function, which performs the mutation:
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
export const mutateSomething = mutation({
  handler: () => {
    // implementation will be here
  },
});
Unlike a query, a mutation can but does not have to return a value.
Mutation arguments
Just like queries, mutations accept named arguments, and the argument values are accessible as fields of the second parameter of the handler function:
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
export const mutateSomething = mutation({
  handler: (_, args: { a: number; b: number }) => {
    // do something with `args.a` and `args.b`
    // optionally return a value
    return "success";
  },
});
Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your mutation.
To both declare the types of arguments and to validate them, add an args object using v validators:
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const mutateSomething = mutation({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    // do something with `args.a` and `args.b`
  },
});
See argument validation for the full list of supported types and validators.
The first parameter to the handler function is reserved for the mutation context.
Mutation responses
Queries can return values of any supported Convex type which will be automatically serialized and deserialized.
Mutations can also return undefined, which is not a valid Convex value. When a mutation returns undefined it is translated to null on the client.
Mutation context
The mutation constructor enables writing data to the database, and other Convex features by passing a MutationCtx object to the handler function as the first parameter:
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const mutateSomething = mutation({
  args: { a: v.number(), b: v.number() },
  handler: (ctx, args) => {
    // Do something with `ctx`
  },
});
Which part of the mutation context is used depends on what your mutation needs to do:
To read from and write to the database use the db field. Note that we make the handler function an async function so we can await the promise returned by db.insert():
convex/myFunctions.ts
TS
import { mutation } from "./_generated/server";
import { v } from "convex/values";
export const addItem = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", { text: args.text });
  },
});
Read on about Writing Data.
To generate upload URLs for storing files use the storage field. Read on about File Storage.
To check user authentication use the auth field. Read on about Authentication.
To schedule functions to run in the future, use the scheduler field. Read on about Scheduled Functions.
Using NPM packages
Mutations can import NPM packages installed in node_modules. Not all NPM packages are supported, see Runtimes for more details.
npm install @faker-js/faker
convex/myFunctions.ts
TS
import { faker } from "@faker-js/faker";
import { mutation } from "./_generated/server";
export const randomName = mutation({
  args: {},
  handler: async (ctx) => {
    faker.seed();
    await ctx.db.insert("tasks", { text: "Greet " + faker.person.fullName() });
  },
});
Calling mutations from clients
To call a mutation from React use the generated useMutation hook:
To call a mutation from React use the useMutation hook along with the generated api object.
src/myApp.tsx
TS
import { useMutation } from "convex/react";
import { api } from "../convex/_generated/api";
export function MyApp() {
  const mutateSomething = useMutation(api.myFunctions.mutateSomething);
  const handleClick = () => {
    mutateSomething({ a: 1, b: 2 });
  };
  // pass `handleClick` to a button
  // ...
}
See the React client documentation for all the ways queries can be called.
When mutations are called from the React or Rust clients, they are executed one at a time in a single, ordered queue. You don't have to worry about mutations editing the database in a different order than they were triggered.
Transactions
Mutations run transactionally. This means that:
All database reads inside the transaction get a consistent view of the data in the database. You don't have to worry about a concurrent update changing the data in the middle of the execution.
All database writes get committed together. If the mutation writes some data to the database, but later throws an error, no data is actually written to the database.
For this to work, similarly to queries, mutations must be deterministic, and cannot call third party APIs. To call third party APIs, use actions.
Actions
Actions can call third party services to do things such as processing a payment with Stripe. They can be run in Convex's JavaScript environment or in Node.js. They can interact with the database indirectly by calling queries and mutations.
Example: GIPHY Action
Action names
Actions follow the same naming rules as queries, see Query names.
The action constructor
To declare an action in Convex you use the action constructor function. Pass it an object with a handler function, which performs the action:
convex/myFunctions.ts
TS
import { action } from "./_generated/server";
export const doSomething = action({
  handler: () => {
    // implementation goes here
    // optionally return a value
    return "success";
  },
});
Unlike a query, an action can but does not have to return a value.
Action arguments and responses
Action arguments and responses follow the same rules as mutations:
convex/myFunctions.ts
TS
import { action } from "./_generated/server";
import { v } from "convex/values";
export const doSomething = action({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    // do something with `args.a` and `args.b`
    // optionally return a value
    return "success";
  },
});
The first argument to the handler function is reserved for the action context.
Action context
The action constructor enables interacting with the database, and other Convex features by passing an ActionCtx object to the handler function as the first argument:
convex/myFunctions.ts
TS
import { action } from "./_generated/server";
import { v } from "convex/values";
export const doSomething = action({
  args: { a: v.number(), b: v.number() },
  handler: (ctx, args) => {
    // do something with `ctx`
  },
});
Which part of that action context is used depends on what your action needs to do:
To read data from the database use the runQuery field, and call a query that performs the read:
convex/myFunctions.ts
TS
import { action, internalQuery } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";
export const doSomething = action({
  args: { a: v.number() },
  handler: async (ctx, args) => {
    const data = await ctx.runQuery(internal.myFunctions.readData, {
      a: args.a,
    });
    // do something with `data`
  },
});
export const readData = internalQuery({
  args: { a: v.number() },
  handler: async (ctx, args) => {
    // read from `ctx.db` here
  },
});
Here readData is an internal query because we don't want to expose it to the client directly. Actions, mutations and queries can be defined in the same file.
To write data to the database use the runMutation field, and call a mutation that performs the write:
convex/myFunctions.ts
TS
import { v } from "convex/values";
import { action } from "./_generated/server";
import { internal } from "./_generated/api";
export const doSomething = action({
  args: { a: v.number() },
  handler: async (ctx, args) => {
    const data = await ctx.runMutation(internal.myMutations.writeData, {
      a: args.a,
    });
    // do something else, optionally use `data`
  },
});
Use an internal mutation when you want to prevent users from calling the mutation directly.
As with queries, it's often convenient to define actions and mutations in the same file.
To generate upload URLs for storing files use the storage field. Read on about File Storage.
To check user authentication use the auth field. Auth is propagated automatically when calling queries and mutations from the action. Read on about Authentication.
To schedule functions to run in the future, use the scheduler field. Read on about Scheduled Functions.
To search a vector index, use the vectorSearch field. Read on about Vector Search.
Dealing with circular type inference
Working around the TypeScript error: some action implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
Calling third-party APIs and using NPM packages
Actions can run in Convex's custom JavaScript environment or in Node.js.
By default, actions run in Convex's environment. This environment supports fetch, so actions that simply want to call a third-party API using fetch can be run in this environment:
convex/myFunctions.ts
TS
import { action } from "./_generated/server";
export const doSomething = action({
  args: {},
  handler: async () => {
    const data = await fetch("https://api.thirdpartyservice.com");
    // do something with data
  },
});
Actions running in Convex's environment are faster compared to Node.js, since they don't require extra time to start up before running your action (cold starts). They can also be defined in the same file as other Convex functions. Like queries and mutations they can import NPM packages, but not all are supported.
Actions needing unsupported NPM packages or Node.js APIs can be configured to run in Node.js by adding the "use node" directive at the top of the file. Note that other Convex functions cannot be defined in files with the "use node"; directive.
convex/myAction.ts
TS
"use node";
import { action } from "./_generated/server";
import SomeNpmPackage from "some-npm-package";
export const doSomething = action({
  args: {},
  handler: () => {
    // do something with SomeNpmPackage
  },
});
Learn more about the two Convex Runtimes.
Calling actions from clients
To call an action from React use the useAction hook along with the generated api object.
src/myApp.tsx
TS
import { useAction } from "convex/react";
import { api } from "../convex/_generated/api";
export function MyApp() {
  const performMyAction = useAction(api.myFunctions.doSomething);
  const handleClick = () => {
    performMyAction({ a: 1 });
  };
  // pass `handleClick` to a button
  // ...
}
Unlike mutations, actions from a single client are parallelized. Each action will be executed as soon as it reaches the server (even if other actions and mutations from the same client are running). If your app relies on actions running after other actions or mutations, make sure to only trigger the action after the relevant previous function completes.
Note: In most cases calling an action directly from a client is an anti-pattern. Instead, have the client call a mutation which captures the user intent by writing into the database and then schedules an action:
convex/myFunctions.ts
TS
import { v } from "convex/values";
import { internal } from "./_generated/api";
import { internalAction, mutation } from "./_generated/server";
export const mutationThatSchedulesAction = mutation({
  args: { text: v.string() },
  handler: async (ctx, { text }) => {
    const taskId = await ctx.db.insert("tasks", { text });
    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {
      taskId,
      text,
    });
  },
});
export const actionThatCallsAPI = internalAction({
  args: { taskId: v.id("tasks"), text: v.string() },
  handler: (_, args): void => {
    // do something with `taskId` and `text`, like call an API
    // then run another mutation to store the result
  },
});
This way the mutation can enforce invariants, such as preventing the user from executing the same action twice.
Limits
Actions time out after 10 minutes. Node.js and Convex runtime have 512MB and 64MB memory limit respectively. Please contact us if you have a use case that requires configuring higher limits.
Actions can do up to 1000 concurrent operations, such as executing queries, mutations or performing fetch requests.
For information on other limits, see here.
Error handling
Unlike queries and mutations, actions may have side-effects and therefore can't be automatically retried by Convex when errors occur. For example, say your action calls Stripe to send a customer invoice. If the HTTP request fails, Convex has no way of knowing if the invoice was already sent. Like in normal backend code, it is the responsibility of the caller to handle errors raised by actions and retry the action call if appropriate.
Dangling promises
Make sure to await all promises created within an action. Async tasks still running when the function returns might or might not complete. In addition, since the Node.js execution environment might be reused between action calls, dangling promises might result in errors in subsequent action invocations.
HTTP Actions
HTTP actions allow you to build an HTTP API right in Convex!
HTTP actions take in a Request and return a Response following the Fetch API. HTTP actions can manipulate the request and response directly, and interact with data in Convex indirectly by running queries, mutations, and actions. HTTP actions might be used for receiving webhooks from external applications or defining a public HTTP API.
HTTP actions are exposed at https://<your deployment name>.convex.site (e.g. https://happy-animal-123.convex.site).
Example: HTTP Actions
Defining HTTP actions
HTTP action handlers are defined using the httpAction constructor, similar to the action constructor for normal actions:
convex/myHttpActions.ts
TS
import { httpAction } from "./_generated/server";
export const doSomething = httpAction(async () => {
  // implementation will be here
  return new Response();
});
The first argument to the handler is an ActionCtx object, which provides auth, storage, and scheduler, as well as runQuery, runMutation, runAction.
The second argument contains the Request data. HTTP actions do not support argument validation, as the parsing of arguments from the incoming Request is left entirely to you.
Here's an example:
convex/messages.ts
TS
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
export const postMessage = httpAction(async (ctx, request) => {
  const { author, body } = await request.json();
  await ctx.runMutation(internal.messages.sendOne, {
    body: `Sent via HTTP action: ${body}`,
    author,
  });
  return new Response(null, {
    status: 200,
  });
});
To expose the HTTP Action, export an instance of HttpRouter from the convex/http.ts file. To create the instance call the httpRouter function. On the HttpRouter you can expose routes using the route method:
convex/http.ts
TS
import { httpRouter } from "convex/server";
import { postMessage, getByAuthor, getByAuthorPathSuffix } from "./messages";
const http = httpRouter();
http.route({
  path: "/postMessage",
  method: "POST",
  handler: postMessage,
});
// Define additional routes
http.route({
  path: "/getMessagesByAuthor",
  method: "GET",
  handler: getByAuthor,
});
// Define a route using a path prefix
http.route({
  // Will match /getAuthorMessages/User+123 and /getAuthorMessages/User+234 etc.
  pathPrefix: "/getAuthorMessages/",
  method: "GET",
  handler: getByAuthorPathSuffix,
});
// Convex expects the router to be the default export of `convex/http.js`.
export default http;
You can now call this action via HTTP and interact with data stored in the Convex Database. HTTP actions are exposed on https://<your deployment name>.convex.site.
export DEPLOYMENT_NAME=... # example: "happy-animal-123"
curl -d '{ "author": "User 123", "body": "Hello world" }' \
    -H 'content-type: application/json' "https://$DEPLOYMENT_NAME.convex.site/postMessage"
Like other Convex functions, you can view your HTTP actions in the Functions view of your dashboard and view logs produced by them in the Logs view.
Limits
HTTP actions run in the same environment as queries and mutations so also do not have access to Node.js-specific JavaScript APIs. HTTP actions can call actions, which can run in Node.js.
Like actions, HTTP actions may have side-effects and will not be automatically retried by Convex when errors occur. It is a responsibility of the caller to handle errors and retry the request if appropriate.
Request and response size is limited to 20MB.
HTTP actions support request and response body types of .text(), .json(), .blob(), and .arrayBuffer().
Note that you don't need to define an HTTP action to call your queries, mutations and actions over HTTP if you control the caller, since you can use use the JavaScript ConvexHttpClient or the Python client to call these functions directly.
Debugging
Step 1: Check that your HTTP actions were deployed.
Check the functions page in the dashboard and make sure there's an entry called http.
If not, double check that you've defined your HTTP actions with the httpRouter in a file called http.js or http.ts (the name of the file must match exactly), and that npx convex dev has no errors.
Step 2: Check that you can access your endpoint using curl
Get your URL from the dashboard under Settings > URL and Deploy Key.
Make sure this is the URL that ends in .convex.site, and not .convex.cloud.
Run a curl command to hit one of your defined endpoints, potentially defining a new endpoint specifically for testing
curl -X GET https://happy-animal-123.convex.site/test
Check the logs page in the dashboard to confirm that there's an entry for your HTTP action.
Step 3: Check the request being made by your browser
If you've determined that your HTTP actions have been deployed and are accessible via curl, but there are still issues requesting them from your app, check the exact requests being made by your browser.
Open the Network tab in your browser's developer tools, and trigger your HTTP requests.
Check that this URL matches what you tested earlier with curl -- it ends in .convex.site and has the right deployment name.
You should be able to see these requests in the dashboard logs page.
If you see "CORS error" or messages in the browser console like Access to fetch at '...' from origin '...' has been blocked by CORS policy, you likely need to configure CORS headers and potentially add a handler for the pre-flight OPTIONS request. See this section below.
Common patterns
File Storage
HTTP actions can be used to handle uploading and fetching stored files, see File Storage with HTTP actions.
CORS
To make requests to HTTP actions from a website you need to add Cross-Origin Resource Sharing (CORS) headers to your HTTP actions.
There are existing resources for exactly which CORS headers are required based on the use case. This site provides an interactive walkthrough for what CORS headers to add. Here's an example of adding CORS headers to a Convex HTTP action:
convex/http.ts
TS
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { api } from "./_generated/api";
const http = httpRouter();
http.route({
  path: "/sendImage",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    // Step 1: Store the file
    const blob = await request.blob();
    const storageId = await ctx.storage.store(blob);
    // Step 2: Save the storage ID to the database via a mutation
    const author = new URL(request.url).searchParams.get("author");
    await ctx.runMutation(api.messages.sendImage, { storageId, author });
    // Step 3: Return a response with the correct CORS headers
    return new Response(null, {
      status: 200,
      // CORS headers
      headers: new Headers({
        // e.g. https://mywebsite.com, configured on your Convex dashboard
        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
        Vary: "origin",
      }),
    });
  }),
});
Here's an example of handling a pre-flight OPTIONS request:
convex/http.ts
TS
// Pre-flight request for /sendImage
http.route({
  path: "/sendImage",
  method: "OPTIONS",
  handler: httpAction(async (_, request) => {
    // Make sure the necessary headers are present
    // for this to be a valid pre-flight request
    const headers = request.headers;
    if (
      headers.get("Origin") !== null &&
      headers.get("Access-Control-Request-Method") !== null &&
      headers.get("Access-Control-Request-Headers") !== null
    ) {
      return new Response(null, {
        headers: new Headers({
          // e.g. https://mywebsite.com, configured on your Convex dashboard
          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
          "Access-Control-Allow-Methods": "POST",
          "Access-Control-Allow-Headers": "Content-Type, Digest",
          "Access-Control-Max-Age": "86400",
        }),
      });
    } else {
      return new Response();
    }
  }),
});
Authentication
You can leverage Convex's built-in authentication integration and access a user identity from ctx.auth.getUserIdentity(). To do this call your endpoint with an Authorization header including a JWT token:
myPage.ts
TS
const jwtToken = "...";
fetch("https://<deployment name>.convex.site/myAction", {
  headers: {
    Authorization: `Bearer ${jwtToken}`,
  },
});
Internal Functions
Internal functions can only be called by other functions and cannot be called directly from a Convex client.
By default your Convex functions are public and accessible to clients. Public functions may be called by malicious users in ways that cause surprising results. Internal functions help you mitigate this risk. We recommend using internal functions any time you're writing logic that should not be called from a client.
While internal functions help mitigate risk by reducing the public surface area of your application, you can still validate internal invariants using argument validation and/or authentication.
Use cases for internal functions
Leverage internal functions by:
Calling them from actions via runQuery and runMutation
Calling them from HTTP actions via runQuery, runMutation, and runAction
Scheduling them from other functions to run in the future
Scheduling them to run periodically from cron jobs
Running them using the Dashboard
Running them from the CLI
Defining internal functions
An internal function is defined using internalQuery, internalMutation, or internalAction. For example:
convex/plans.ts
TS
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";
export const markPlanAsProfessional = internalMutation({
  args: { planId: v.id("plans") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.planId, { planType: "professional" });
  },
});
If you need to pass complicated objects to internal functions you might prefer to not use argument validation. Note though that if you're using internalQuery or internalMutation it's a better idea to pass around document IDs instead of documents, to ensure the query or mutation is working with the up-to-date state of the database.
Internal function without argument validation
Calling internal functions
Internal functions can be called from other functions using the internal object.
For example, consider this public upgrade action that calls the internal plans.markPlanAsProfessional mutation we defined above:
convex/changes.ts
TS
import { action } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";
export const upgrade = action({
  args: {
    planId: v.id("plans"),
  },
  handler: async (ctx, args) => {
    // Call out to payment provider (e.g. Stripe) to charge customer
    const response = await fetch("https://...");
    if (response.ok) {
      // Mark the plan as "professional" in the Convex DB
      await ctx.runMutation(internal.plans.markPlanAsProfessional, {
        planId: args.planId,
      });
    }
  },
});
In this example a user should not be able to directly call internal.plans.markPlanAsProfessional without going through the upgrade action — if they did, then they would get a free upgrade.
You can define public and internal functions in the same file.
Error Handling
There are four reasons why your Convex queries and mutations may hit errors:
Application Errors: The function code hits a logical condition that should stop further processing, and your code throws a ConvexError
Developer Errors: There is a bug in the function (like calling db.get(null) instead of db.get(id)).
Read/Write Limit Errors: The function is retrieving or writing too much data.
Internal Convex Errors: There is a problem within Convex (like a network blip).
Convex will automatically handle internal Convex errors. If there are problems on our end, we'll automatically retry your queries and mutations until the problem is resolved and your queries and mutations succeed.
On the other hand, you must decide how to handle application, developer and read/write limit errors. When one of these errors happens, the best practices are to:
Show the user some appropriate UI.
Send the error to an exception reporting service using the Exception Reporting Integration.
Additionally, you might also want to send client-side errors to a service like Sentry to capture additional information for debugging and observability.
Errors in queries
If your query function hits an error, the error will be sent to the client and thrown from your useQuery call site. The best way to handle these errors is with a React error boundary component.
Error boundaries allow you to catch errors thrown in their child component tree, render fallback UI, and send information about the error to your exception handling service. Adding error boundaries to your app is a great way to handle errors in Convex query functions as well as other errors in your React components. If you are using Sentry, you can use their Sentry.ErrorBoundary component.
With error boundaries, you can decide how granular you'd like your fallback UI to be. One simple option is to wrap your entire application in a single error boundary like:
<StrictMode>
  <ErrorBoundary>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </ErrorBoundary>
</StrictMode>,
Then any error in any of your components will be caught by the boundary and render the same fallback UI.
On the other hand, if you'd like to enable some portions of your app to continue functioning even if other parts hit errors, you can instead wrap different parts of your app in separate error boundaries.
RETRYING
Unlike other frameworks, there is no concept of "retrying" if your query function hits an error. Because Convex functions are deterministic, if the query function hits an error, retrying will always produce the same error. There is no point in running the query function with the same arguments again.
Errors in mutations
If a mutation hits an error, this will
Cause the promise returned from your mutation call to be rejected.
Cause your optimistic update to be rolled back.
If you have an exception service like Sentry configured, it should report "unhandled promise rejections" like this automatically. That means that with no additional work your mutation errors should be reported.
Note that errors in mutations won't be caught by your error boundaries because the error doesn't happen as part of rendering your components.
If you would like to render UI specifically in response to a mutation failure, you can use .catch on your mutation call. For example:
sendMessage(newMessageText).catch((error) => {
  // Do something with `error` here
});
If you're using an async handled function you can also use try...catch:
try {
  await sendMessage(newMessageText);
} catch (error) {
  // Do something with `error` here
}
REPORTING CAUGHT ERRORS
If you handle your mutation error, it will no longer become an unhandled promise rejection. You may need to report this error to your exception handling service manually.
Errors in action functions
Unlike queries and mutations, actions may have side-effects and therefore can't be automatically retried by Convex when errors occur. For example, say your action sends a email. If it fails part-way through, Convex has no way of knowing if the email was already sent and can't safely retry the action. It is responsibility of the caller to handle errors raised by actions and retry if appropriate.
Differences in error reporting between dev and prod
Using a dev deployment any server error thrown on the client will include the original error message and a server-side stack trace to ease debugging.
Using a production deployment any server error will be redacted to only include the name of the function and a generic "Server Error" message, with no stack trace. Server application errors will still include their custom data.
Both development and production deployments log full errors with stack traces which can be found on the Logs page of a given deployment.
Application errors, expected failures
If you have expected ways your functions might fail, you can either return different values or throw ConvexErrors.
See Application Errors.
Read/write limit errors
To ensure uptime and guarantee performance, Convex will catch queries and mutations that try to read or write too much data. These limits are enforced at the level of a single query or mutation function execution. The limits are:
Queries and mutations error out when:
More than 16384 documents are scanned
More than 8MiB worth of data is scanned
More than 4096 queries calls to db.get or db.query are made
The function spends more than 1 second executing Javascript
In addition, mutations error out when:
More than 8192 documents are written
More than 8MiB worth of data is written
Documents are "scanned" by the database to figure out which documents should be returned from db.query. So for example db.query("table").take(5).collect() will only need to scan 5 documents, but db.query("table").filter(...).first() might scan up to as many documents as there are in "table", to find the first one that matches the given filter.
Number of calls to db.get and db.query has a limit to prevent a single query from subscribing to too many index ranges.
In general, if you're running into these limits frequently, we recommend indexing your queries to reduce the number of documents scanned, allowing you to avoid unnecessary reads. Queries that scan large swaths of your data may look innocent at first, but can easily blow up at any production scale. If your functions are close to hitting these limits they will log a warning.
For information on other limits, see here.
Debugging Errors
See Debugging and specifically Finding relevant logs by Request ID.
Application Errors
If you have expected ways your functions might fail, you can either return different values or throw ConvexErrors.
Returning different values
If you're using TypeScript different return types can enforce that you're handling error scenarios.
For example, a createUser mutation could return
Id<"users"> | { error: "EMAIL_ADDRESS_IN_USE" };
to express that either the mutation succeeded or the email address was already taken.
This ensures that you remember to handle these cases in your UI.
Throwing application errors
You might prefer to throw errors for the following reasons:
You can use the exception bubbling mechanism to throw from a deeply nested function call, instead of manually propagating error results up the call stack. This will work for runQuery, runMutation and runAction calls in actions too.
In mutations, throwing an error will prevent the mutation transaction from committing
On the client, it might be simpler to handle all kinds of errors, both expected and unexpected, uniformly
Convex provides an error subclass, ConvexError, which can be used to carry information from the backend to the client:
convex/myFunctions.ts
TS
import { ConvexError } from "convex/values";
import { mutation } from "./_generated/server";
export const assignRole = mutation({
  args: {
    // ...
  },
  handler: (ctx, args) => {
    const isTaken = isRoleTaken(/* ... */);
    if (isTaken) {
      throw new ConvexError("Role is already taken");
    }
    // ...
  },
});
Application error data payload
You can pass the same data types supported by function arguments, return types and the database, to the ConvexError constructor. This data will be stored on the data property of the error:
// error.data === "My fancy error message"
throw new ConvexError("My fancy error message");
// error.data === {message: "My fancy error message", code: 123, severity: "high"}
throw new ConvexError({
  message: "My fancy error message",
  code: 123,
  severity: "high",
});
// error.data === {code: 123, severity: "high"}
throw new ConvexError({
  code: 123,
  severity: "high",
});
Error payloads more complicated than a simple string are helpful for more structured error logging, or for handling sets of errors differently on the client.
Handling application errors on the client
On the client, application errors also use the ConvexError class, and the data they carry can be accessed via the data property:
src/App.tsx
TS
import { ConvexError } from "convex/values";
import { useMutation } from "convex/react";
import { api } from "../convex/_generated/api";
export function MyApp() {
  const doSomething = useMutation(api.myFunctions.mutateSomething);
  const handleSomething = async () => {
    try {
      await doSomething({ a: 1, b: 2 });
    } catch (error) {
      const errorMessage =
        // Check whether the error is an application error
        error instanceof ConvexError
          ? // Access data and cast it to the type we expect
            (error.data as { message: string }).message
          : // Must be some developer error,
            // and prod deployments will not
            // reveal any more information about it
            // to the client
            "Unexpected error occurred";
      // do something with `errorMessage`
    }
  };
  // ...
}
The Zen of Convex
Convex is an opinionated framework, with every element designed to pull developers into the pit of success.
The Zen of Convex is a set of guidelines & best practices developers have discovered that keep their projects falling into this wonderful pit.
Performance
Double down on the reactor
There's a reason why a deterministic, reactive database is the beating heart of Convex: the more you center your apps around its properties, the better your projects will fare over time. Your projects will be easier to understand and refactor. Your app's performance will stay screaming fast. You won't have any consistency or state management problems.
Use a query for nearly every app read
Keep reactor functions light & fast
Use actions sparingly and incrementally
Don't over-complicate client-side state management
Convex builds in a ton of its own caching and consistency controls into the app's client library. Rather than reinvent the wheel, let your client-side code take advantage of these built-in performance boosts.
Let Convex handle caching & consistency
Be thoughtful about the return values of mutations
Architecture
Create server-side frameworks using "just code"
Convex's built-in primitives are pretty low level! They're just functions. What about authentication frameworks? What about object-relational mappings? Do you need to wait until Convex ships some in-built feature to get those? Nope. In general, you should solve composition and encapsulation problems in your server-side Convex code using the same methods you use for the rest of your TypeScript code bases. After all, this is why Convex is "just code!" Stack always has great examples of ways to tackle these needs.
Don't misuse actions
Actions are powerful, but it's important to be intentional in how they fit into your app's data flow.
Don't invoke actions directly from your app
Don't think 'background jobs', think 'workflow'
Record progress one step at a time
Development workflow
Keep the dashboard by your side
Working on your Convex project without using the dashboard is like driving a car with your eyes closed. The dashboard lets you view logs, give mutations/queries/actions a test run, make sure your configuration and codebase are as you expect, inspect your tables, generate schemas, etc. It's an invaluable part of your rapid development cycle.
Don't go it alone
Between these docs, Stack, and our community, someone has probably encountered the design or architectural issue you're facing. So why try to figure things out the hard way, when you can take advantage of a whole community's experience?
Class: ConvexReactClient
react.ConvexReactClient

A Convex client for use within React.

This loads reactive queries and executes mutations over a WebSocket.

Constructors
constructor
• new ConvexReactClient(address, options?)

Parameters
Name	Type	Description
address	string	The url of your Convex deployment, often provided by an environment variable. E.g. https://small-mouse-123.convex.cloud.
options?	ConvexReactClientOptions	See ConvexReactClientOptions for a full description.
Defined in
react/client.ts:235

Methods
setAuth
▸ setAuth(fetchToken, onChange?): void

Set the authentication token to be used for subsequent queries and mutations. fetchToken will be called automatically again if a token expires. fetchToken should return null if the token cannot be retrieved, for example when the user's rights were permanently revoked.

Parameters
Name	Type	Description
fetchToken	AuthTokenFetcher	an async function returning the JWT-encoded OpenID Connect Identity Token
onChange?	(isAuthenticated: boolean) => void	a callback that will be called when the authentication status changes
Returns
void

Defined in
react/client.ts:283

clearAuth
▸ clearAuth(): void

Clear the current authentication token if set.

Returns
void

Defined in
react/client.ts:305

watchQuery
▸ watchQuery<Query>(query, ...argsAndOptions): Watch<FunctionReturnType<Query>>

Construct a new Watch on a Convex query function.

Most application code should not call this method directly. Instead use the useQuery hook.

Type parameters
Name	Type
Query	extends FunctionReference<"query">
Parameters
Name	Type	Description
query	Query	A FunctionReference for the public query to run.
...argsAndOptions	ArgsAndOptions<Query, WatchQueryOptions>	-
Returns
Watch<FunctionReturnType<Query>>

The Watch object.

Defined in
react/client.ts:336

mutation
▸ mutation<Mutation>(mutation, ...argsAndOptions): Promise<FunctionReturnType<Mutation>>

Execute a mutation function.

Type parameters
Name	Type
Mutation	extends FunctionReference<"mutation">
Parameters
Name	Type	Description
mutation	Mutation	A FunctionReference for the public mutation to run.
...argsAndOptions	ArgsAndOptions<Mutation, MutationOptions<FunctionArgs<Mutation>>>	-
Returns
Promise<FunctionReturnType<Mutation>>

A promise of the mutation's result.

Defined in
react/client.ts:406

action
▸ action<Action>(action, ...args): Promise<FunctionReturnType<Action>>

Execute an action function.

Type parameters
Name	Type
Action	extends FunctionReference<"action">
Parameters
Name	Type	Description
action	Action	A FunctionReference for the public action to run.
...args	OptionalRestArgs<Action>	An arguments object for the action. If this is omitted, the arguments will be {}.
Returns
Promise<FunctionReturnType<Action>>

A promise of the action's result.

Defined in
react/client.ts:427
Interface: ConvexReactClientOptions
react.ConvexReactClientOptions

Options for ConvexReactClient.

Hierarchy
BaseConvexClientOptions

↳ ConvexReactClientOptions

Properties
unsavedChangesWarning
• Optional unsavedChangesWarning: boolean

Whether to prompt the user if they have unsaved changes pending when navigating away or closing a web page.

This is only possible when the window object exists, i.e. in a browser.

The default value is true in browsers.

Inherited from
BaseConvexClientOptions.unsavedChangesWarning

Defined in
browser/sync/client.ts:56

webSocketConstructor
• Optional webSocketConstructor: Object

Call signature
• new webSocketConstructor(url, protocols?): WebSocket

Specifies an alternate WebSocket constructor to use for client communication with the Convex cloud. The default behavior is to use WebSocket from the global environment.

Parameters
Name	Type
url	string | URL
protocols?	string | string[]
Returns
WebSocket

Type declaration
Name	Type
prototype	WebSocket
CONNECTING	0
OPEN	1
CLOSING	2
CLOSED	3
Inherited from
BaseConvexClientOptions.webSocketConstructor

Defined in
browser/sync/client.ts:63

verbose
• Optional verbose: boolean

Adds additional logging for debugging purposes.

The default value is false.

Inherited from
BaseConvexClientOptions.verbose

Defined in
browser/sync/client.ts:69

reportDebugInfoToConvex
• Optional reportDebugInfoToConvex: boolean

Sends additional metrics to Convex for debugging purposes.

The default value is false.

Inherited from
BaseConvexClientOptions.reportDebugInfoToConvex

Defined in
browser/sync/client.ts:75

skipConvexDeploymentUrlCheck
• Optional skipConvexDeploymentUrlCheck: boolean

Skip validating that the Convex deployment URL looks like https://happy-animal-123.convex.cloud or localhost.

This can be useful if running a self-hosted Convex backend that uses a different URL.

The default value is false

Inherited from
BaseConvexClientOptions.skipConvexDeploymentUrlCheck

Defined in
browser/sync/client.ts:85
Interface: MutationOptions<Args>
react.MutationOptions

Options for mutation.

Type parameters
Name	Type
Args	extends Record<string, Value>
Properties
optimisticUpdate
• Optional optimisticUpdate: OptimisticUpdate<Args>

An optimistic update to apply along with this mutation.

An optimistic update locally updates queries while a mutation is pending. Once the mutation completes, the update will be rolled back.

Defined in
react/client.ts:203

Interface: ReactAction<Action>
react.ReactAction

An interface to execute a Convex action on the server.

Type parameters
Name	Type
Action	extends FunctionReference<"action">
Callable
ReactAction
▸ ReactAction(...args): Promise<FunctionReturnType<Action>>

Execute the function on the server, returning a Promise of its return value.

Parameters
Name	Type	Description
...args	OptionalRestArgs<Action>	Arguments for the function to pass up to the server.
Returns
Promise<FunctionReturnType<Action>>

The return value of the server-side function call.

Defined in
react/client.ts:116
Interface: ReactMutation<Mutation>
react.ReactMutation

An interface to execute a Convex mutation function on the server.

Type parameters
Name	Type
Mutation	extends FunctionReference<"mutation">
Callable
ReactMutation
▸ ReactMutation(...args): Promise<FunctionReturnType<Mutation>>

Execute the mutation on the server, returning a Promise of its return value.

Parameters
Name	Type	Description
...args	OptionalRestArgs<Mutation>	Arguments for the mutation to pass up to the server.
Returns
Promise<FunctionReturnType<Mutation>>

The return value of the server-side function call.

Defined in
react/client.ts:47

Methods
withOptimisticUpdate
▸ withOptimisticUpdate(optimisticUpdate): ReactMutation<Mutation>

Define an optimistic update to apply as part of this mutation.

This is a temporary update to the local query results to facilitate a fast, interactive UI. It enables query results to update before a mutation executed on the server.

When the mutation is invoked, the optimistic update will be applied.

Optimistic updates can also be used to temporarily remove queries from the client and create loading experiences until a mutation completes and the new query results are synced.

The update will be automatically rolled back when the mutation is fully completed and queries have been updated.

Parameters
Name	Type	Description
optimisticUpdate	OptimisticUpdate<FunctionArgs<Mutation>>	The optimistic update to apply.
Returns
ReactMutation<Mutation>

A new ReactMutation with the update configured.

Defined in
react/client.ts:70
Interface: Watch<T>
react.Watch

A watch on the output of a Convex query function.

Type parameters
Name
T
Methods
onUpdate
▸ onUpdate(callback): () => void

Initiate a watch on the output of a query.

This will subscribe to this query and call the callback whenever the query result changes.

Important: If the client is already subscribed to this query with the same arguments this callback will not be invoked until the query result is updated. To get the current, local result call localQueryResult.

Parameters
Name	Type	Description
callback	() => void	Function that is called whenever the query result changes.
Returns
fn

A function that disposes of the subscription.
▸ (): void

Initiate a watch on the output of a query.

This will subscribe to this query and call the callback whenever the query result changes.

Important: If the client is already subscribed to this query with the same arguments this callback will not be invoked until the query result is updated. To get the current, local result call localQueryResult.

Returns
void

A function that disposes of the subscription.
Defined in
react/client.ts:148

localQueryResult
▸ localQueryResult(): undefined | T

Get the current result of a query.

This will only return a result if we're already subscribed to the query and have received a result from the server or the query value has been set optimistically.

Throws

An error if the query encountered an error on the server.

Returns
undefined | T

The result of the query or undefined if it isn't known.

Defined in
react/client.ts:160

journal
▸ journal(): undefined | QueryJournal

Get the current QueryJournal for this query.

If we have not yet received a result for this query, this will be undefined.

Returns
undefined | QueryJournal

Defined in
react/client.ts:172
Interface: WatchQueryOptions
react.WatchQueryOptions

Options for watchQuery.

Properties
journal
• Optional journal: QueryJournal

An (optional) journal produced from a previous execution of this query function.

If there is an existing subscription to a query function with the same name and arguments, this journal will have no effect.

Defined in
react/client.ts:188
Module: react-clerk
React login component for use with Clerk.

Functions
ConvexProviderWithClerk
▸ ConvexProviderWithClerk(«destructured»): Element

A wrapper React component which provides a ConvexReactClient authenticated with Clerk.

It must be wrapped by a configured ClerkProvider, from @clerk/clerk-react, @clerk/clerk-expo, @clerk/nextjs or another React-based Clerk client library and have the corresponding useAuth hook passed in.

See Convex Clerk on how to set up Convex with Clerk.

Parameters
Name	Type
«destructured»	Object
› children	ReactNode
› client	IConvexReactClient
› useAuth	UseAuth
Returns
Element

Defined in
react-clerk/ConvexProviderWithClerk.tsx:38

Generated Code
Convex uses code generation to create code that is specific to your app's data model and API. Convex generates JavaScript files (.js) with TypeScript type definitions (.d.ts).

Code generation isn't required to use Convex, but using the generated code will give you more better autocompletion in your editor and more type safety if you're using TypeScript.

To generate the code, run:

npx convex dev

This creates a convex/_generated directory that contains:

api.js and api.d.ts
dataModel.d.ts
server.js and server.d.ts
dataModel.d.ts
THIS CODE IS GENERATED
These exports are not directly available in the convex package!

Instead you must run npx convex dev to create convex/_generated/dataModel.d.ts.

Generated data model types.

Types
TableNames
Ƭ TableNames: string

The names of all of your Convex tables.

Doc
Ƭ Doc<TableName>: Object

The type of a document stored in Convex.

Type parameters
Name	Type	Description
TableName	extends TableNames	A string literal type of the table name (like "users").
Id
An identifier for a document in Convex.

Convex documents are uniquely identified by their Id, which is accessible on the _id field. To learn more, see Document IDs.

Documents can be loaded using db.get(id) in query and mutation functions.

IDs are just strings at runtime, but this type can be used to distinguish them from other strings when type checking.

This is an alias of GenericId that is typed for your data model.

Type parameters
Name	Type	Description
TableName	extends TableNames	A string literal type of the table name (like "users").
DataModel
Ƭ DataModel: Object

A type describing your Convex data model.

This type includes information about what tables you have, the type of documents stored in those tables, and the indexes defined on them.

This type is used to parameterize methods like queryGeneric and mutationGeneric to make them type-safe.

api.js
THIS CODE IS GENERATED
These exports are not directly available in the convex package!

Instead you need to run npx convex dev to create convex/_generated/api.js and convex/_generated/api.d.ts.

These types require running code generation because they are specific to the Convex functions you define for your app.

If you aren't using code generation, you can use makeFunctionReference instead.

api
An object of type API describing your app's public Convex API.

Its API type includes information about the arguments and return types of your app's Convex functions.

The api object is used by client-side React hooks and Convex functions that run or schedule other functions.

src/App.jsx
import { api } from "../convex/_generated/api";
import { useQuery } from "convex/react";

const data = useQuery(api.messages.list);

internal
Another object of type API describing your app's internal Convex API.

convex/upgrade.js
import { action } from "../_generated/server";
import { internal } from "../_generated/api";

export default action(async ({ runMutation }, { planId, ... }) => {
  // Call out to payment provider (e.g. Stripe) to charge customer
  const response = await fetch(...);
  if (response.ok) {
    // Mark the plan as "professional" in the Convex DB
    await runMutation(internal.plans.markPlanAsProfessional, { planId });
  }
});

server.js
THIS CODE IS GENERATED
These exports are not directly available in the convex package!

Instead you must run npx convex dev to create convex/_generated/server.js and convex/_generated/server.d.ts.

Generated utilities for implementing server-side Convex query and mutation functions.

Functions
query
▸ query(func): RegisteredQuery

Define a query in this Convex app's public API.

This function will be allowed to read your Convex database and will be accessible from the client.

This is an alias of queryGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The query function. It receives a QueryCtx as its first argument.
Returns
RegisteredQuery

The wrapped query. Include this as an export to name it and make it accessible.

internalQuery
▸ internalQuery(func): RegisteredQuery

Define a query that is only accessible from other Convex functions (but not from the client).

This function will be allowed to read from your Convex database. It will not be accessible from the client.

This is an alias of internalQueryGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The query function. It receives a QueryCtx as its first argument.
Returns
RegisteredQuery

The wrapped query. Include this as an export to name it and make it accessible.

mutation
▸ mutation(func): RegisteredMutation

Define a mutation in this Convex app's public API.

This function will be allowed to modify your Convex database and will be accessible from the client.

This is an alias of mutationGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The mutation function. It receives a MutationCtx as its first argument.
Returns
RegisteredMutation

The wrapped mutation. Include this as an export to name it and make it accessible.

internalMutation
▸ internalMutation(func): RegisteredMutation

Define a mutation that is only accessible from other Convex functions (but not from the client).

This function will be allowed to read and write from your Convex database. It will not be accessible from the client.

This is an alias of internalMutationGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The mutation function. It receives a MutationCtx as its first argument.
Returns
RegisteredMutation

The wrapped mutation. Include this as an export to name it and make it accessible.

action
▸ action(func): RegisteredAction

Define an action in this Convex app's public API.

An action is a function which can execute any JavaScript code, including non-deterministic code and code with side-effects, like calling third-party services. They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive. They can interact with the database indirectly by calling queries and mutations using the ActionCtx.

This is an alias of actionGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The action function. It receives an ActionCtx as its first argument.
Returns
RegisteredAction

The wrapped function. Include this as an export to name it and make it accessible.

internalAction
▸ internalAction(func): RegisteredAction

Define an action that is only accessible from other Convex functions (but not from the client).

This is an alias of internalActionGeneric that is typed for your app's data model.

Parameters
Name	Description
func	The action function. It receives an ActionCtx as its first argument.
Returns
RegisteredAction

The wrapped action. Include this as an export to name it and make it accessible.

httpAction
▸ httpAction(func: (ctx: ActionCtx, request: Request) => Promise<Response>): PublicHttpAction

Parameters
Name	Type	Description
func	(ctx: ActionCtx, request: Request) => Promise<Response>	The function. It receives an ActionCtx as its first argument and a Request as its second argument.
Returns
PublicHttpAction

The wrapped function. Import this function from convex/http.js and route it to hook it up.

Types
QueryCtx
Ƭ QueryCtx: Object

A set of services for use within Convex query functions.

The query context is passed as the first argument to any Convex query function run on the server.

This differs from the MutationCtx because all of the services are read-only.

This is an alias of GenericQueryCtx that is typed for your app's data model.

Type declaration
Name	Type
db	DatabaseReader
auth	Auth
storage	StorageReader
MutationCtx
Ƭ MutationCtx: Object

A set of services for use within Convex mutation functions.

The mutation context is passed as the first argument to any Convex mutation function run on the server.

This is an alias of GenericMutationCtx that is typed for your app's data model.

Type declaration
Name	Type
db	DatabaseWriter
auth	Auth
storage	StorageWriter
scheduler	Scheduler
ActionCtx
Ƭ ActionCtx: Object

A set of services for use within Convex action functions.

The action context is passed as the first argument to any Convex action function run on the server.

This is an alias of ActionCtx that is typed for your app's data model.

Type declaration
Name	Type
runQuery	(name: string, args?: Record<string, Value>) => Promise<Value>
runMutation	(name: string, args?: Record<string, Value>) => Promise<Value>
runAction	(name: string, args?: Record<string, Value>) => Promise<Value>
auth	Auth
scheduler	Scheduler
storage	StorageActionWriter
vectorSearch	(tableName: string, indexName: string, query: VectorSearchQuery) => Promise<Array<{ _id: Id, _score: number }>>
DatabaseReader
An interface to read from the database within Convex query functions.

This is an alias of GenericDatabaseReader that is typed for your app's data model.

DatabaseWriter
An interface to read from and write to the database within Convex mutation functions.

This is an alias of GenericDatabaseWriter that is typed for your app's data model.